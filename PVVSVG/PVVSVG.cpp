// PVVSVG.cpp : This file contains the 'main' function. Program execution begins and ends there.
//
// GIT TEST

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string>
#include <iostream>
#include <vector>
#include <algorithm>
#include <fstream>

static constexpr float kPTs2mm = 25.4f / 72.0f;

struct P
{
	float x;
	float y;

	P() : x(0), y(0) {}
	P(const float xf, const float yf) : x(xf), y(yf) {}
};

struct COLOR
{
	float r;
	float g;
	float b;
	float a;

	COLOR(float rf, float gf, float bf, float af) : r(rf), g(gf), b(bf), a(af) {}
};

struct BOUNDS
{
	P m_lb;
	P m_rt;

	BOUNDS(const P &lb, const P &rt) : m_lb(lb), m_rt(rt) {}
	BOUNDS() : m_lb(P(1.0e30f, 1.0e30f)), m_rt(P(-1.0e30f, -1.0e30f)) {}

	float GetWidth() const { return m_rt.x - m_lb.x; }
	float GetHeight() const { return m_rt.y - m_lb.y; }

	const BOUNDS& operator+=(const P &p)
	{
		if (p.x < m_lb.x)
			m_lb.x = p.x;

		if (p.x > m_rt.x)
			m_rt.x = p.x;

		if (p.y < m_lb.y)
			m_lb.y = p.y;

		if (p.y > m_rt.y)
			m_rt.y = p.y;

		return *this;
	}
};

static bool BeginsWith(const std::string &s, const std::string &prefix)
{
	const auto iFound = s.find(prefix);
	return (iFound == 0);
}

static std::vector<std::string> SplitString(const std::string &s, const std::string &delimeters)
{
	std::vector<std::string> tokens;
	int64_t iPos = 0;
	int64_t iStart = 0;
	int64_t iEnd = 0;
	while ((iPos >= 0) && ((iStart = s.find_first_not_of(delimeters, iPos)) >= 0))
	{
		iEnd = s.find_first_of(delimeters, iStart);
		tokens.push_back(s.substr(iStart, (iEnd >= 0) ? (iEnd - iStart) : iEnd));
		iPos = iEnd;
	}

	return tokens;
}

static float Pop(std::vector<float> &fstack) // return mm
{
	if (fstack.empty())
	{
		printf("POP ON EMPTY STACK!\n");
		exit(-1);
	}

	const float value = fstack.back();
	fstack.pop_back();
	return value * kPTs2mm;
}

int main(int argc, const char* argv[])
{
	if (argc < 3)
	{
		printf("Usage:\n");
		printf("PVVSVG file.ai outfile.svg\n");
		exit(0);
	}




	FILE* fp = fopen(argv[2], "wb");
	if (!fp)
	{
		printf("FAILED to open \"%s\" for write.\n", argv[2]);
		exit(-1);
	}
	fprintf(fp, "<?xml version=\"1.0\" standalone=\"no\"?>\n");
	fprintf(fp, "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \n");
	fprintf(fp, "  \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n");

	std::vector<std::string> allTokens;
	std::ifstream in(argv[1]);
	if (in)
	{
		std::string line;
		while (std::getline(in, line))
		{
			if (line.empty())
				continue;
			if (line[0] == '%')
				continue;
			if (BeginsWith(line, "Adobe"))
				continue;

			std::vector<std::string> tokens = SplitString(line, " ");
			allTokens.insert(allTokens.end(), tokens.begin(), tokens.end());
		}
	}

	std::vector<float> fstack;
	fstack.reserve(1000);
	COLOR current_color(0,0,0,1);
	BOUNDS bounds;
	for (int iToken = 0; iToken < allTokens.size(); iToken++)
	{
		const auto &token = allTokens[iToken];
		if (!token.empty())
		{
			if (token[0] == 'K') // color
			{
				const float A = Pop(fstack);
				const float B = Pop(fstack);
				const float G = Pop(fstack);
				const float R = Pop(fstack);
				current_color = COLOR(R, G, B, A);
			}
			else if (token[0] == 'm') // move
			{
				const float y = Pop(fstack);
				const float x = Pop(fstack);
				bounds += P(x, y);
			}
			else if (token[0] == 'L') // lineto
			{
				const float y = Pop(fstack);
				const float x = Pop(fstack);
				bounds += P(x, y);
			}
			else if (token[0] == 'C') // curveto
			{
				const float y3 = Pop(fstack);
				const float x3 = Pop(fstack);
				const float y2 = Pop(fstack);
				const float x2 = Pop(fstack);
				const float y1 = Pop(fstack);
				const float x1 = Pop(fstack);
				bounds += P(x1, y1);
				bounds += P(x2, y2);
				bounds += P(x3, y3);
			}
			else if (token[0] == 's') // stroke
			{
			}
			else
			{
				if (isdigit(token[0]) || (token[0] == '-'))
				{
					const float f = (float)atof(token.c_str());
					fstack.push_back(f);
				}
				else
				{
					printf("ERROR UNRECOGNIZED TOKEN!!!\n");
					exit(-1);
				}
			}
		}
	}

	fprintf(fp, "<svg width=\"%fmm\" height=\"%fmm\"  viewBox=\"%f %f %f %f\" version=\"1.1\"\n", bounds.GetWidth(), bounds.GetHeight(),
		bounds.m_lb.x, bounds.m_lb.y, bounds.GetWidth(), bounds.GetHeight());
	fprintf(fp, "     xmlns=\"http://www.w3.org/2000/svg\">\n");
	fprintf(fp, "<desc>generated by PVVSVG</desc>\n");

	//fprintf(fp, "<rect x=\"5mm\" y=\"5mm\" width=\"20mm\" height=\"10mm\"/>\n");

	// 'z' is closepath...
	const float yflip = bounds.m_lb.y + bounds.m_rt.y;
	for (int iToken = 0; iToken < allTokens.size(); iToken++)
	{
		const auto &token = allTokens[iToken];
		if (!token.empty())
		{
			if (token[0] == 'K') // color
			{
				const float A = Pop(fstack);
				const float B = Pop(fstack);
				const float G = Pop(fstack);
				const float R = Pop(fstack);
				current_color = COLOR(R, G, B, A);
			}
			else if (token[0] == 'm') // move
			{
				const float y = Pop(fstack);
				const float x = Pop(fstack);
				fprintf(fp, "  <path d=\"M %.2f %.2f", x, yflip - y);
			}
			else if (token[0] == 'L') // lineto
			{
				const float y = Pop(fstack);
				const float x = Pop(fstack);
				fprintf(fp, " L %.2f %.2f", x, yflip - y);
			}
			else if (token[0] == 'C') // curveto
			{
				const float y3 = Pop(fstack);
				const float x3 = Pop(fstack);
				const float y2 = Pop(fstack);
				const float x2 = Pop(fstack);
				const float y1 = Pop(fstack);
				const float x1 = Pop(fstack);
				fprintf(fp, " C %.2f %.2f %.2f %.2f %.2f %.2f", x1, yflip - y1, x2, yflip - y2, x3, yflip - y3);
			}
			else if (token[0] == 's') // stroke
			{
				fprintf(fp, "\" fill=\"none\" stroke=\"black\" stroke-width=\"1\" />\n");
			}
			else
			{
				if (isdigit(token[0]) || (token[0] == '-'))
				{
					const float f = (float)atof(token.c_str());
					fstack.push_back(f);
				}
				else
				{
					printf("ERROR UNRECOGNIZED TOKEN!!!\n");
					exit(-1);
				}
			}
		}
	}



	fprintf(fp, "</svg>\n");

#if 0
    
    <rect x="0.5cm" y="2cm" width="1cm" height="1.5cm"/>
    <rect x="3cm" y="0.5cm" width="1.5cm" height="2cm"/>
    <rect x="3.5cm" y="3cm" width="1cm" height="0.5cm"/>

  <!-- Show outline of canvas using 'rect' element -->
  <rect x=".01cm" y=".01cm" width="4.98cm" height="3.98cm"
        fill="none" stroke="blue" stroke-width=".02cm" />
#endif


	fclose(fp);
}

// Run program: Ctrl + F5 or Debug > Start Without Debugging menu
// Debug program: F5 or Debug > Start Debugging menu

// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file
